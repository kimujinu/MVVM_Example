디자인패턴 사용목적 : MVC, MVP, MVVM 모두 화면에서 보여주는 로직과 데이터가 처리되는 로직을 서로 분리시켜서
                   코드를 깔끔하게 만들고, 서로의 역할을 나눔으로써 유지보수와 개발 효율을 높이는데 목적

MVVM 동작 순서 : 1. 사용자의 Action이 View를 통해 들어온다.
                2. Command패턴을 이용해 ViewModel에 Action을 전달한다.
                3. ViewModel이 Model에서 데이터를 요청하고, Model은 ViewModel에서 요청받은 데이터를 전달
                4. ViewModel은 응답받은 데이터를 가공, 저장
                5. View는 ViewModel과의 Data Binding을 이용해 화면을 갱신한다.

          장점 : View와 Model 사이의 의존성이 없음.
                View와 ViewModel사이의 의존성 또한 존재하지 않는다.
                각 부분들은 독립적이기 때문에 개별적 개발이 가능.

         View : 사용자에게 보이는 화면
   View Model : View를 표현하기 위해 만든 View를 위한 Model.View를 나타내주기 위한 데이터처리 담당
                - 사용목적 : UI와 로직의 분리, 액티비티와 프래그먼트는 UI를 업데이트 하는데만 주력할 수 있고,
                            ViewModel에 있는 데이터는 액티비티or프래그먼트의 라이프사이클로부터 자유로워 지기위해
                            ViewModel에 있는 데이터는 싱글톤 객체처럼 사용이 가능해서 프래그먼트 사이에서 ViewModel을
                            이용해 데이터를 쉽게 공유할 수 있음.
                - onCleared() : ViewModel에는 onCleared()함수가 존재한다. 이것은 onDestory()가 호출된 후 실행되는 함수이다.
        Model : 어플에서 사용되는 데이터 및 데이터 조작 부분(ex. 서버에서 들어오는 데이터)
     LiveData : 식별 가능한 데이터 홀더 클래스이다. 스스로 라이프사이클을 인식하여 장점이 존재.
                LiveData는 ViewModel과 함께 사용해야 효과가 커짐. ViewModel 안에 있는 LiveData 객체를
                DataBinding을 통해 UI에서 관찰만 할 수 있도록 만들면 액티비티나 프래그먼트에서 일일히 데이터를
                갱신할 필요 없이 알아서 UI에 최신 데이터가 보이게 될 것이다.
                - 장점 : UI와 데이터 상태의 일치 보장
                        메모리 누출이 없음
                        비정상 종료가 없음
                        수명주기를 자동으로 관리
                        최신의 데이터 유지
                        기기회전 등 프래그먼트나 액티비티가 재생성되어도 데이터의 변화 없음

데이터바인딩 : - 직접 액티비티에 뷰를 바인딩해주는 수작업을 막기위해 사용
             - findViewById() 사용하지 않아도 된다. 자동으로 xml에서 만든 View들을 만들어준다.
             - RecyclerView 사용시 각각의 item들을 set 해주지 않아도 알아서 xml에서 처리할 수 있다.
             - Observable을 이용해 실시간으로 데이터를 바꿔줄 수 있다.
             - build.gradle(Module:app)에 따로 옵션설정.
             - 해당 xml에 layout, data으로 감싸준다.



